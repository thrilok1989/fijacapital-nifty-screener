import asyncio
from typing import Dict, List, Optional, Any
import logging
from datetime import datetime
from telegram import Bot, Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from telegram.error import TelegramError, RetryAfter
import json
from config import Config

logger = logging.getLogger(__name__)

class TelegramNotifier:
    """Telegram notification system with command handling"""
    
    def __init__(self, bot_token: str = None, chat_id: str = None):
        self.bot_token = bot_token or Config.TELEGRAM_BOT_TOKEN
        self.chat_id = chat_id or Config.TELEGRAM_CHAT_ID
        
        if not self.bot_token or not self.chat_id:
            raise ValueError("Telegram Bot Token and Chat ID are required")
        
        self.bot = Bot(token=self.bot_token)
        self.application = None
        self.commands = {}
        
        logger.info("Telegram Notifier initialized")
    
    async def send_signal(self, signal_data: Dict) -> bool:
        """Send trading signal to Telegram"""
        
        message = self._format_signal_message(signal_data)
        
        try:
            await self.bot.send_message(
                chat_id=self.chat_id,
                text=message,
                parse_mode='HTML',
                disable_web_page_preview=True,
                disable_notification=False
            )
            
            logger.info(f"Signal sent for {signal_data.get('symbol')}: "
                       f"{signal_data.get('signal_type')}")
            return True
            
        except RetryAfter as e:
            logger.warning(f"Rate limited: {e}. Retrying after {e.retry_after} seconds")
            await asyncio.sleep(e.retry_after)
            return await self.send_signal(signal_data)
            
        except TelegramError as e:
            logger.error(f"Telegram error sending signal: {e}")
            return False
    
    def _format_signal_message(self, signal_data: Dict) -> str:
        """Format signal message for Telegram"""
        
        symbol = signal_data.get('symbol', 'NIFTY')
        signal_type = signal_data.get('signal_type', 'HOLD')
        confidence = signal_data.get('confidence', 0) * 100
        ai_model = signal_data.get('model_version', 'Groq AI')
        
        # Emoji mapping
        emoji_map = {
            'BUY_CALL': 'ğŸ“ˆğŸŸ¢',
            'BUY_PUT': 'ğŸ“‰ğŸ”´',
            'SELL_CALL': 'ğŸ“‰ğŸŸ¢',
            'SELL_PUT': 'ğŸ“ˆğŸ”´',
            'HOLD': 'â¸ï¸âšª'
        }
        
        emoji = emoji_map.get(signal_type, 'ğŸ¤–')
        
        # Format numbers
        def format_number(num):
            if isinstance(num, (int, float)):
                if abs(num) >= 1e6:
                    return f"{num/1e6:.2f}M"
                elif abs(num) >= 1e3:
                    return f"{num/1e3:.1f}K"
                return f"{num:.2f}"
            return str(num)
        
        message = f"""
{emoji} <b>GROQ-AI EXPIRY SPIKE SIGNAL</b> {emoji}

ğŸ¤– <b>AI Model:</b> {ai_model}
ğŸ“Š <b>Symbol:</b> {symbol}
ğŸ¯ <b>Signal:</b> {signal_type.replace('_', ' ')} {emoji}
ğŸ“ˆ <b>Confidence:</b> {confidence:.1f}%
â±ï¸ <b>Time:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

<b>ğŸ“Š KEY METRICS:</b>
â€¢ Spike Score: {signal_data.get('spike_score', 0):.2f}
â€¢ Gamma Exposure: {format_number(signal_data.get('gamma_exposure', 0))}
â€¢ Volume Ratio: {signal_data.get('volume_ratio', 0):.2f}x
â€¢ Days to Expiry: {signal_data.get('days_to_expiry', 0)}
â€¢ PCR (Volume): {signal_data.get('put_call_ratio_volume', 0):.2f}

<b>ğŸ¯ TRADE DETAILS:</b>
â€¢ Action: {signal_data.get('signal_type', 'HOLD').replace('_', ' ')}
â€¢ Price Target: {format_number(signal_data.get('price_target', 0))}
â€¢ Stop Loss: {format_number(signal_data.get('stop_loss', 0))}
â€¢ Timeframe: {signal_data.get('timeframe_hours', 24)} hours
â€¢ Position Size: {signal_data.get('position_size_percent', 0)}%

<b>ğŸ“ AI RATIONALE:</b>
{signal_data.get('rationale', 'No rationale provided')[:400]}...

<b>âš ï¸ KEY RISKS:</b>
{', '.join(signal_data.get('key_risk_factors', ['Standard market risks']))[:150]}

<b>ğŸ“° NEWS CONTEXT:</b>
{self._format_news_context(signal_data.get('news_context', []))}

<b>ğŸš€ ENTRY:</b>
{signal_data.get('entry_strategy', 'N/A')[:150]}

<b>ğŸ”š EXIT:</b>
{signal_data.get('exit_strategy', 'N/A')[:150]}

<b>ğŸ‘€ MONITOR:</b>
{', '.join(signal_data.get('monitoring_parameters', ['Market conditions']))[:100]}

<code>Generated by AI Trading System</code>
"""
        return message
    
    def _format_news_context(self, news_context: List[Dict]) -> str:
        """Format news context for message"""
        if not news_context:
            return "ğŸ“° No relevant news"
        
        formatted = []
        for i, news in enumerate(news_context[:2], 1):
            title = news.get('title', '')[:50] + '...' if len(news.get('title', '')) > 50 else news.get('title', '')
            sentiment = news.get('sentiment', {}).get('category', 'neutral').upper()
            formatted.append(f"{i}. {title} [{sentiment}]")
        
        return "\n".join(formatted)
    
    async def send_alert(self, alert_type: str, message: str, 
                        notification: bool = True) -> bool:
        """Send general alert"""
        try:
            await self.bot.send_message(
                chat_id=self.chat_id,
                text=f"ğŸš¨ <b>{alert_type}</b>\n\n{message}",
                parse_mode='HTML',
                disable_notification=not notification
            )
            return True
            
        except RetryAfter as e:
            logger.warning(f"Rate limited: {e}")
            await asyncio.sleep(e.retry_after)
            return await self.send_alert(alert_type, message, notification)
            
        except TelegramError as e:
            logger.error(f"Telegram alert error: {e}")
            return False
    
    async def send_data_table(self, title: str, data: List[Dict], 
                            columns: List[str]) -> bool:
        """Send data as formatted table"""
        try:
            if not data:
                await self.send_alert(f"{title} - No Data", "No data available")
                return True
            
            # Create table header
            table = f"<b>{title}</b>\n\n"
            table += "<code>"
            
            # Add headers
            headers = " | ".join(columns)
            table += f"{headers}\n"
            table += "-" * len(headers) + "\n"
            
            # Add rows
            for row in data[:10]:  # Limit to 10 rows
                row_values = []
                for col in columns:
                    value = row.get(col, '')
                    if isinstance(value, float):
                        value = f"{value:.2f}"
                    elif isinstance(value, (int, np.integer)):
                        value = str(value)
                    row_values.append(str(value)[:20])  # Truncate long values
                
                table += " | ".join(row_values) + "\n"
            
            table += "</code>"
            
            await self.bot.send_message(
                chat_id=self.chat_id,
                text=table,
                parse_mode='HTML',
                disable_web_page_preview=True
            )
            return True
            
        except Exception as e:
            logger.error(f"Error sending data table: {e}")
            return False
    
    async def start_bot(self, command_handlers: Dict = None):
        """Start Telegram bot with command handlers"""
        
        self.application = Application.builder().token(self.bot_token).build()
        
        # Default command handlers
        default_handlers = {
            'start': self._handle_start,
            'help': self._handle_help,
            'status': self._handle_status,
            'analysis': self._handle_analysis
        }
        
        # Merge with custom handlers
        if command_handlers:
            default_handlers.update(command_handlers)
        
        self.commands = default_handlers
        
        # Register command handlers
        for command, handler in default_handlers.items():
            self.application.add_handler(CommandHandler(command, handler))
        
        # Register message handler for unknown commands
        self.application.add_handler(
            MessageHandler(filters.TEXT & ~filters.COMMAND, self._handle_message)
        )
        
        logger.info("Starting Telegram bot...")
        
        # Start polling
        await self.application.initialize()
        await self.application.start()
        await self.application.updater.start_polling()
        
        # Send startup message
        await self.send_alert(
            "SYSTEM STARTUP",
            f"AI Trading System started at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
            f"Monitoring: {', '.join(Config.SYMBOLS)}\n"
            f"Check interval: {Config.CHECK_INTERVAL} seconds",
            notification=False
        )
        
        # Keep running
        await self.application.idle()
    
    async def _handle_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        welcome_message = """
ğŸ¤– <b>AI Trading System Bot</b>

Available commands:
/start - Show this message
/help - Show help information
/status - Show system status
/analysis [symbol] - Get market analysis
/signals [count] - Show recent signals
/gamma [symbol] - Show gamma data
/spikes [symbol] - Show volume spikes

Example:
/analysis NIFTY
/signals 5
        """
        
        await update.message.reply_text(welcome_message, parse_mode='HTML')
    
    async def _handle_help(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command"""
        help_message = """
ğŸ“š <b>Help Guide</b>

This bot monitors options expiry spikes using AI analysis.

<b>Key Features:</b>
â€¢ Real-time expiry spike detection
â€¢ Gamma sequence analysis
â€¢ Volume spike monitoring
â€¢ AI-powered trading signals
â€¢ Market news integration

<b>How it works:</b>
1. System monitors option chains every 5 minutes
2. Detects volume and gamma anomalies
3. Uses ML (XGBoost) for spike prediction
4. Groq AI analyzes data and generates signals
5. Sends Telegram alerts for actionable signals

<b>Risk Warning:</b>
â€¢ This is for educational purposes only
â€¢ Always do your own research
â€¢ Past performance doesn't guarantee future results
â€¢ Options trading involves high risk
        """
        
        await update.message.reply_text(help_message, parse_mode='HTML')
    
    async def _handle_status(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /status command"""
        from main import orchestrator  # Import here to avoid circular imports
        
        status_message = f"""
ğŸ¥ <b>System Status</b>

ğŸ“… <b>Current Time:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
ğŸ“Š <b>Market Open:</b> {'âœ… Yes' if Config.is_market_open() else 'âŒ No'}
ğŸ” <b>Monitoring:</b> {', '.join(Config.SYMBOLS)}
â±ï¸ <b>Check Interval:</b> {Config.CHECK_INTERVAL} seconds
ğŸ¯ <b>Spike Threshold:</b> {Config.SPIKE_THRESHOLD}

ğŸ¤– <b>AI System:</b>
â€¢ Model: {Config.GROQ_MODEL}
â€¢ Temperature: {Config.AI_TEMPERATURE}
â€¢ Max Tokens: {Config.AI_MAX_TOKENS}

ğŸ“ˆ <b>Performance:</b>
â€¢ Analysis Count: {getattr(orchestrator, 'analysis_count', 0)}
â€¢ Last Cycle: {getattr(orchestrator, 'last_cycle_time', 'N/A')}

ğŸ’¾ <b>Database:</b> Connected
ğŸ“° <b>News API:</b> {'âœ… Connected' if Config.NEWSAPI_KEY else 'âŒ Disabled'}
ğŸ¤– <b>ML Model:</b> {'âœ… Loaded' if getattr(orchestrator, 'ml_detector', None) else 'âŒ Not loaded'}
        """
        
        await update.message.reply_text(status_message, parse_mode='HTML')
    
    async def _handle_analysis(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /analysis command"""
        symbol = context.args[0] if context.args else Config.SYMBOLS[0]
        
        if symbol not in Config.SYMBOLS:
            await update.message.reply_text(
                f"âŒ Symbol {symbol} not monitored. Available: {', '.join(Config.SYMBOLS)}"
            )
            return
        
        # This would fetch and send analysis
        # For now, send placeholder
        await update.message.reply_text(
            f"ğŸ” Analysis for {symbol} requested...\n"
            f"This feature will be implemented in the next update.",
            parse_mode='HTML'
        )
    
    async def _handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle regular messages"""
        await update.message.reply_text(
            "ğŸ¤– I'm an AI trading system bot. Use /help to see available commands."
        )
    
    async def stop_bot(self):
        """Stop Telegram bot"""
        if self.application:
            await self.application.stop()
            await self.application.shutdown()
            logger.info("Telegram bot stopped")
    
    async def broadcast_to_all(self, message: str, 
                              chat_ids: List[str] = None) -> Dict[str, bool]:
        """Broadcast message to multiple chat IDs"""
        results = {}
        
        target_chats = chat_ids or [self.chat_id]
        
        for chat_id in target_chats:
            try:
                await self.bot.send_message(
                    chat_id=chat_id,
                    text=message,
                    parse_mode='HTML'
                )
                results[chat_id] = True
            except TelegramError as e:
                logger.error(f"Error broadcasting to {chat_id}: {e}")
                results[chat_id] = False
        
        return results
